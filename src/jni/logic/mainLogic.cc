#pragma once
#include "DebugLevels.h"
#define DEBUG_LEVEL DEBUG_LEVEL_DBG

#include "Comm/Communication.h"
#include "Comm/JsonDecoder.h"
#include "Configuration.h"
#include "Debug.h"
#include "DebugCommands.h"
#include "Hardware/Duet.h"
#include "Hardware/Usb.h"
#include "Library/bmp.h"
#include "ObjectModel/Alert.h"
#include "ObjectModel/Fan.h"
#include "ObjectModel/Files.h"
#include "ObjectModel/Heightmap.h"
#include "ObjectModel/PrinterStatus.h"
#include "ObjectModel/Utils.h"
#include "Storage.h"
#include "UI/ExtrusionControl.h"
#include "UI/FileList.h"
#include "UI/Gcodes.h"
#include "UI/Graph.h"
#include "UI/GuidedSetup.h"
#include "UI/Heightmap.h"
#include "UI/ObjectCancel.h"
#include "UI/OmObserver.h"
#include "UI/Themes.h"
#include "UI/UserInterface.h"
#include "UI/Webcam.h"
#include "Upgrade/Upgrade.h"
#include "manager/LanguageManager.h"
#include "os/MountMonitor.h"
#include "os/UpgradeMonitor.h"
#include "storage/StoragePreferences.h"
#include "timer.h"
#include "utils/BrightnessHelper.h"
#include "utils/TimeHelper.h"
#include <string>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <unistd.h>
#include <vector>

/*
 * This file is generated by the GUI tool
 * File function: logic corresponding code for processing users
 * Function Description:
 *========================onButtonClick_XXXX
 When the button on the page is pressed, the system will call the corresponding function.
 XXX represents the [ID value] name in the GUI tool, such as Button1.
 When the return value is false, the system will no longer process this button,
 and when it returns true, the system will continue to process this button. Such as SYS_BACK.
 *========================onSlideWindowItemClick_XXXX(int index)
 When there is a sliding window on the page and the user clicks the icon of the sliding window, the system will call this function.
 XXX represents the [ID value] name in the GUI tool, for example: slideWindow1.
 index represents the offset value of the pressed icon
 *========================onSeekBarChange_XXXX(int progress)
 When there is a slider on the page and the user changes the progress, the system will call this function.
 XXX represents the [ID value] name in the GUI tool, such as SeekBar1.
 progress represents the current progress value
 *========================ogetListItemCount_XXXX()
 When there is a sliding list on the page, the system will call this interface to obtain the total number of lists when updating.
 XXX represents the [ID value] name in the GUI tool, such as List1.
 The return value is the total number of items in the current list
 *========================oobtainListItemData_XXXX(ZKListView::ZKListItem *pListItem, int index)
 When there is a sliding list on the page, the system will call this interface
 to obtain the content information under the current item of the list when updating,
 XXX represents the [ID value] name in the GUI tool. For example, List1.
 pListItem is a single item object in the map and index is the offset of the list's total purpose.
 See function description for details
 *========================Commonly used interface===============
 * LOGD(...)  interface to print debugging information
 * mTextXXXPtr->setText("****") Display text on the control TextXXX
 * mButton1Ptr->setSelected(true); Set the control mButton1 to the selected mode, the picture will be switched to the selected picture, and the button text will be switched to the selected color
 * mSeekBarPtr->setProgress(12) Adjust the progress to 12 on the control mSeekBar
 * mListView1Ptr->refreshListView() Make mListView1 re-refresh, call when the list data changes
 * mDashbroadView1Ptr->setTargetAngle(120) Adjust the pointer display angle on the control mDashbroadView1 to 120 degrees
 *
 * In Eclipse IDE, use the "alt + /" shortcut key to open the smart prompt
 */

/**
 * Register timer
 * Fill the array to register the timer
 * Note: id cannot be repeated
 */
static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = {
	{TIMER_DELAYED_TASK, 50},
	{TIMER_ASYNC_HTTP_REQUEST, 50},
	{TIMER_THUMBNAIL, 50},
};

/**
 * Triggered when the interface is constructed
 */
static void onUI_init()
{
	// Tips : Add the display code for UI initialization here, such as: mText1Ptr->setText("123");
	srand(0);
	InitUpgradeMountListener();

	initTimer(mActivityPtr);
	registerUserTimer(TIMER_UPDATE_DATA,
					  (int)DEFAULT_PRINTER_POLL_INTERVAL); // Register here so it can be reset with stored poll interval

	// Buzzer
	mBuzzerEnabledPtr->setChecked(StoragePreferences::getBool(ID_BUZZER_ENABLED, true));

	// Comm
	Comm::DUET.Init();

	// UI
	UI::Init(mRootWindowPtr);
	UI::TEMPERATURE_GRAPH.Init(mTempGraphPtr, mTempGraphXLabelsPtr, mTempGraphYLabelsPtr, mTemperatureGraphLegendPtr);
	UI::Theme::SetTheme(StoragePreferences::getString(ID_THEME, "dark"));
	OM::FileSystem::Init(mFolderIDPtr, mFileListViewPtr);
	UI::WINDOW.AddHome(mMainWindowPtr);
	UI::ToolsList::Create("home")->Init(mToolListViewPtr);
	UI::ToolsList::Create("print")->Init(mPrintTemperatureListPtr);
	UI::ExtrusionControl::Init();
	UI::CONSOLE.Init(mConsoleListViewPtr, mConsoleInputPtr);
	UI::NUMPAD_WINDOW.Init(mNumPadWindowPtr, mNumPadHeaderPtr, mNumPadInputPtr);
	UI::SLIDER_WINDOW.Init(
		mSliderWindowPtr, mSliderPtr, mSliderHeaderPtr, mSliderValuePtr, mSliderPrefixPtr, mSliderSuffixPtr);
	UI::SetThumbnail(mPopupImagePtr);

	// Guided setup
	UI::GuidedSetup::Init(mGuidedSetupWindowPtr);
	mShowSetupOnStartupPtr->setSelected(
		StoragePreferences::getBool(ID_SHOW_SETUP_ON_STARTUP, DEFAULT_SHOW_SETUP_ON_STARTUP));

	// Screensaver
	bool screensaverEnable = StoragePreferences::getBool(ID_SCREENSAVER_ENABLE, true);
	mScreensaverEnablePtr->setSelected(screensaverEnable);
	EASYUICONTEXT->setScreensaverEnable(screensaverEnable);
	mScreensaverTimeoutInputPtr->setText(StoragePreferences::getInt(ID_SCREENSAVER_TIMEOUT, 120));

	// Duet communication settings
	mCommunicationTypePtr->setText(Comm::duetCommunicationTypeNames[(int)Comm::DUET.GetCommunicationType()]);
	mHostnameInputPtr->setText(Comm::DUET.GetHostname());
	mPasswordInputPtr->setText(Comm::DUET.GetPassword());
	mPollIntervalInputPtr->setText((int)Comm::DUET.GetPollInterval());
	mInfoTimeoutInputPtr->setText((int)UI::POPUP_WINDOW.GetTimeout());

	// Heightmap
	UI::SetHeightmapRenderMode(UI::HeightmapRenderMode(StoragePreferences::getInt(ID_HEIGHTMAP_RENDER_MODE, 0)));
	UI::RenderScale();

	// Object Cancel
	mObjectCancelPainterPtr->setTouchable(true);
	mObjectCancelPainterPtr->setTouchListener(&UI::ObjectCancel::GetTouchListener());

	// Webcams
	UI::Webcam::RestoreWebcamSettings();

	// Hide clock here so that it is visible when editing the GUI
	mDigitalClock1Ptr->setVisible(false);

	/* Initialise UI observer updaters that run on each field value that is received from the OM */
	auto* observer = UI::g_omFieldObserverHead;
	while (observer != nullptr)
	{
		observer->Init(UI::g_observerMap);
		observer = observer->next;
	}

	/* Initialise UI observer updaters that run after an array has been received */
	auto* observerArrayEnd = UI::g_omArrayEndObserverHead;
	while (observerArrayEnd != nullptr)
	{
		observerArrayEnd->Init(UI::g_observerMapArrayEnd);
		observerArrayEnd = observerArrayEnd->next;
	}

	info("UI initialized");
}

/**
 * Triggered when switching to this interface
 */
static void onUI_intent(const Intent *intentPtr)
{
	if (intentPtr != NULL)
	{
		//TODO
	}
}

/*
 * Triggered when the interface is displayed
 */
static void onUI_show() {}

/*
 * Triggered when the interface is hidden
 */
static void onUI_hide() {}

/*
 * Triggered when the interface completely exits
 */
static void onUI_quit() {}

/**
 * Serial data callback interface
 */
static void onProtocolDataUpdate(const SProtocolData &rxData)
{
	// We want a single decoder for all uart data
	static Comm::JsonDecoder decoder;
	decoder.CheckInput(rxData.data, rxData.len);
}

/**
 * Timer trigger function
 * It is not recommended to write time-consuming operations in this function, otherwise it will affect UI refresh
 * Parameters:
 * 	- id: The id of the currently triggered timer is the same as the id at registration
 * Return value:
 * 	- True: Continue to run the current timer
 * 	- False: Stop running the current timer
 */
static bool onUI_Timer(int id)
{
	switch (id)
	{

	case TIMER_UPDATE_DATA:
	{
		static OM::PrinterStatus status = OM::PrinterStatus::unknown;
		if (status != OM::GetStatus())
		{
			status = OM::GetStatus();
			mStatusTextPtr->setTextTr(OM::GetStatusText());
		}
		Comm::sendNext();
		break;
	}
	case TIMER_DELAYED_TASK: {
		runDelayedCallbacks();
		break;
	}
	case TIMER_ASYNC_HTTP_REQUEST: {
		Comm::ProcessQueuedAsyncRequests();
		break;
	}
	case TIMER_THUMBNAIL: {
		FILEINFO_CACHE->Spin();
		break;
	}
	default:
		break;
	}

	return true;
}

/**
 * Triggered when there is a new touch event
 * Parameters:
 * 	- ev: New touch event
 * Return value:
 * 	- True: Indicates that the touch event is intercepted here, and the system will no longer pass this touch event to the control
 * 	- False: Touch events will continue to be passed to the control
 */
static bool onmainActivityTouchEvent(const MotionEvent &ev)
{
	switch (ev.mActionStatus)
	{
	case MotionEvent::E_ACTION_DOWN: // touch pressed
		break;
	case MotionEvent::E_ACTION_MOVE: // touch slide
		break;
	case MotionEvent::E_ACTION_UP: // touch released
		break;
	default:
		break;
	}
	return false;
}

// =====================================================================================================================
// Side Bar
// =====================================================================================================================

static bool onButtonClick_HomeBtn(ZKButton *pButton)
{
	dbg(" ButtonClick HomeBtn !!!\n");
	UI::WINDOW.Home();
	return false;
}
static bool onButtonClick_BackBtn(ZKButton *pButton)
{
	dbg("Back btn pressed, returning to previous window");
	UI::WINDOW.Back();
	return false;
}

static bool onButtonClick_MacroBtn(ZKButton *pButton)
{
	OM::FileSystem::RequestFiles("0:/macros");
	UI::WINDOW.OpenWindow(mFilesWindowPtr);
	return false;
}

static bool onButtonClick_ConsoleBtn(ZKButton* pButton)
{
	UI::WINDOW.OpenWindow(mConsoleWindowPtr);
    return false;
}

static bool onButtonClick_EStopBtn(ZKButton *pButton)
{
	UI::POPUP_WINDOW.Close();
	Comm::DUET.SendGcode("M112 ;"
						 "\xF0"
						 "\x0F");
	Thread::sleep(1000);
	Comm::DUET.SendGcode("M999");
	return false;
}

// =====================================================================================================================
// Main Window
// =====================================================================================================================

static int getListItemCount_ToolListView(const ZKListView *pListView)
{
	size_t count = UI::ToolsList::Get("home")->GetTotalHeaterCount(false);
	return count;
}

static void obtainListItemData_ToolListView(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index)
{
	UI::ToolsList::Get("home")->ObtainListItemData(pListItem,
												   index,
												   ID_MAIN_ToolNameSubItem,
												   ID_MAIN_ToolStatusSubItem,
												   ID_MAIN_ToolCurrentTemperatureSubItem,
												   ID_MAIN_ToolActiveTemperatureSubItem,
												   ID_MAIN_ToolStandbyTemperatureSubItem);
}

static void onListItemClick_ToolListView(ZKListView *pListView, int index, int id)
{
	UI::ToolsList::Get("home")->OnListItemClick(
			index, id,
			ID_MAIN_ToolNameSubItem, ID_MAIN_ToolStatusSubItem,
			ID_MAIN_ToolActiveTemperatureSubItem, ID_MAIN_ToolStandbyTemperatureSubItem);
}

static void onSlideItemClick_SlideWindow1(ZKSlideWindow *pSlideWindow, int index)
{
	dbg(" onSlideItemClick_ SlideWindow1 %d !!!\n", index);
	switch (index)
	{
	case (int)UI::SlideWindowIndex::move:
		UI::WINDOW.OpenWindow(ID_MAIN_MoveWindow);
		break;
	case (int)UI::SlideWindowIndex::extrude:
		UI::WINDOW.OpenWindow(ID_MAIN_ExtrudeWindow);
		break;
	case (int)UI::SlideWindowIndex::status:
		UI::WINDOW.OpenWindow(ID_MAIN_PrintWindow);
		break;
	case (int)UI::SlideWindowIndex::heightmap: {
		OM::RequestHeightmapFiles();
		UI::WINDOW.OpenWindow(ID_MAIN_HeightMapWindow);
		UI::RenderHeightmap(OM::GetCurrentHeightmap());
		break;
	}
	case (int)UI::SlideWindowIndex::fans:
		UI::WINDOW.OpenWindow(ID_MAIN_FanWindow);
		break;
	case (int)UI::SlideWindowIndex::print:
		OM::FileSystem::RequestFiles("0:/gcodes");
		UI::WINDOW.OpenWindow(ID_MAIN_FilesWindow);
		break;
	case (int)UI::SlideWindowIndex::network:
		// UI::WINDOW.OpenWindow(mNetworkWindowPtr);
		EASYUICONTEXT->openActivity("WifiSettingActivity");
		break;
	case (int)UI::SlideWindowIndex::settings:
		UI::WINDOW.OpenWindow(ID_MAIN_SettingsWindow);
		break;
	case (int)UI::SlideWindowIndex::object_cancel:
		UI::WINDOW.OpenWindow(ID_MAIN_ObjectCancelWindow);
		break;
	case (int)UI::SlideWindowIndex::webcam:
		UI::Webcam::RegisterUpdateLoop();
		UI::WINDOW.OpenWindow(ID_MAIN_WebcamWindow);
		break;
	default:
		break;
	}
}
static int getListItemCount_TemperatureGraphLegend(const ZKListView *pListView)
{
	return OM::GetAnalogSensorCount();
}

static void obtainListItemData_TemperatureGraphLegend(ZKListView *pListView, ZKListView::ZKListItem *pListItem, int index)
{
	OM::AnalogSensor* sensor = OM::GetAnalogSensorBySlot(index);
	if (sensor == nullptr)
	{
		pListItem->setText("");
		return;
	}
	pListItem->setText(sensor->name.c_str());
	pListItem->setSelected(!UI::TEMPERATURE_GRAPH.IsWaveVisible(index));
}

static void onListItemClick_TemperatureGraphLegend(ZKListView *pListView, int index, int id)
{
	UI::TEMPERATURE_GRAPH.SetWaveVisible(index, !UI::TEMPERATURE_GRAPH.IsWaveVisible(index));
}

// =====================================================================================================================
// Popups
// =====================================================================================================================

static bool onButtonClick_NumPad0(ZKButton* pButton)
{
	UI::NUMPAD_WINDOW.AddOneChar('0');
	return false;
}

static bool onButtonClick_NumPad1(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('1');
	return false;
}

static bool onButtonClick_NumPad2(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('2');
	return false;
}

static bool onButtonClick_NumPad3(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('3');
	return false;
}

static bool onButtonClick_NumPad4(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('4');
	return false;
}

static bool onButtonClick_NumPad5(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('5');
	return false;
}

static bool onButtonClick_NumPad6(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('6');
	return false;
}

static bool onButtonClick_NumPad7(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('7');
	return false;
}

static bool onButtonClick_NumPad8(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('8');
	return false;
}

static bool onButtonClick_NumPad9(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.AddOneChar('9');
	return false;
}

static bool onButtonClick_NumPadDel(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.DelOneChar();
	return false;
}

static bool onButtonClick_NumPadConfirm(ZKButton *pButton) {
	UI::NUMPAD_WINDOW.Confirm();
	return false;
}

static bool onButtonClick_NumPadCloseBtn(ZKButton* pButton)
{
	LOGD(" ButtonClick NumPadCloseBtn !!!\n");
	UI::NUMPAD_WINDOW.Close();
	return false;
}

static bool onButtonClick_NumPadClearBtn(ZKButton* pButton)
{
	LOGD(" ButtonClick NumPadClearBtn !!!\n");
	UI::NUMPAD_WINDOW.ClearValue();
	return false;
}

// =====================================================================================================================
// Move Window
// =====================================================================================================================

static bool onButtonClick_HomeAllBtn(ZKButton *pButton) {
	Comm::DUET.SendGcode("G28\n");
	return false;
}

static bool onButtonClick_TrueLevelBtn(ZKButton* pButton)
{
	Comm::DUET.SendGcode("G32\n");
	return false;
}

static bool onButtonClick_MeshLevelBtn(ZKButton* pButton)
{
	Comm::DUET.SendGcode("G29\n");
	return false;
}

static bool onButtonClick_DisableMotorsBtn(ZKButton* pButton)
{
	Comm::DUET.SendGcode("M18\n");
	return false;
}

static bool onButtonClick_HeightmapBtn(ZKButton* pButton)
{
	UI::WINDOW.OpenWindow(ID_MAIN_HeightMapWindow);
	return false;
}

static int getListItemCount_AxisControlListView(const ZKListView* pListView)
{
	return OM::Move::GetAxisCount();
}

static void obtainListItemData_AxisControlListView(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	ZKListView::ZKListSubItem* pHome = pListItem->findSubItemByID(ID_MAIN_AxisControlHomeSubItem);
	ZKListView::ZKListSubItem* pMachinePosition = pListItem->findSubItemByID(ID_MAIN_AxisControlMachinePositionSubItem);
	ZKListView::ZKListSubItem* pUserPosition = pListItem->findSubItemByID(ID_MAIN_AxisControlUserPositionSubItem);
	OM::Move::Axis* axis = OM::Move::GetAxisBySlot(index);
	if (axis == nullptr) return;

	pHome->setTextTrf("axis_control_home", axis->letter);
	pHome->setSelected(axis->homed);
	pUserPosition->setText(axis->userPosition);
	pMachinePosition->setTextf("(%.2f)", axis->machinePosition);
}

static void onListItemClick_AxisControlListView(ZKListView* pListView, int index, int id)
{
	OM::Move::Axis* axis = OM::Move::GetAxisBySlot(index);
	if (axis == nullptr) return;

	int distance = 0;
	switch (id)
	{
	case ID_MAIN_AxisControlHomeSubItem:
		Comm::DUET.SendGcodef("G28 %s\n", axis->letter);
		return;
	case ID_MAIN_AxisControlSubItem1:
		distance = -50;
		break;
	case ID_MAIN_AxisControlSubItem2:
		distance = -10;
		break;
	case ID_MAIN_AxisControlSubItem3:
		distance = -1;
		break;
	case ID_MAIN_AxisControlSubItem4:
		distance = -0.1;
		break;
	case ID_MAIN_AxisControlSubItem5:
		distance = 0.1;
		break;
	case ID_MAIN_AxisControlSubItem6:
		distance = 1;
		break;
	case ID_MAIN_AxisControlSubItem7:
		distance = 10;
		break;
	case ID_MAIN_AxisControlSubItem8:
		distance = 50;
		break;
	}
	Comm::DUET.SendGcodef("G91\nG1 %s%d F%d\nG90\n", axis->letter, distance, UI::g_defaultMoveFeedRate * 60);
}

static int getListItemCount_MoveFeedrate(const ZKListView* pListView)
{
	// LOGD("getListItemCount_MoveFeedrate !\n");
	return ARRAY_SIZE(UI::g_moveFeedRates);
}

static void obtainListItemData_MoveFeedrate(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	if (index < 0 || index >= (int)ARRAY_SIZE(UI::g_moveFeedRates))
	{
		return;
	}
	pListItem->setTextf("%d", UI::g_moveFeedRates[index]);
	pListItem->setSelected(UI::g_defaultMoveFeedRate == UI::g_moveFeedRates[index]);
}

static void onListItemClick_MoveFeedrate(ZKListView* pListView, int index, int id)
{
	if (index < 0 || index >= (int)ARRAY_SIZE(UI::g_moveFeedRates))
	{
		return;
	}
	UI::g_defaultMoveFeedRate = UI::g_moveFeedRates[index];
}

// =====================================================================================================================
// Console Window
// =====================================================================================================================

static int getListItemCount_ConsoleListView(const ZKListView *pListView) {
    //LOGD("getListItemCount_ConsoleListView !\n");
	return MAX_RESPONSE_LINES;
}

static void obtainListItemData_ConsoleListView(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) {
    //LOGD(" obtainListItemData_ ConsoleListView  !!!\n");
	pListItem->setText(UI::CONSOLE.GetItem(index).c_str());
}

static void onListItemClick_ConsoleListView(ZKListView *pListView, int index, int id) {
    //LOGD(" onListItemClick_ ConsoleListView  !!!\n");
}

static int getListItemCount_GcodeListView(const ZKListView *pListView) {
	return sizeof(s_gcode) / sizeof(gcode);
}

static void obtainListItemData_GcodeListView(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) {
	pListItem->setTextTr(s_gcode[index].displayText);
}

static void onListItemClick_GcodeListView(ZKListView *pListView, int index, int id) {
}

static void onEditTextChanged_ConsoleInput(const std::string& text)
{
	UI::CONSOLE.AddCommand(text);
	Comm::DUET.SendGcode(text.c_str());
}

static bool onButtonClick_SendBtn(ZKButton* pButton)
{
	UI::CONSOLE.AddCommand(mConsoleInputPtr->getText());
	Comm::DUET.SendGcode(mConsoleInputPtr->getText().c_str());
	return true;
}
static bool onButtonClick_ConsoleClearBtn(ZKButton *pButton) {
    UI::CONSOLE.Clear();
    return false;
}

static bool onButtonClick_FileRefreshBtn(ZKButton *pButton) {
	UI::POPUP_WINDOW.Close();
	FILEINFO_CACHE->ClearCache();
	OM::FileSystem::ClearFileSystem();
	OM::FileSystem::RequestFiles(OM::FileSystem::GetCurrentDirPath());
    return false;
}
static int getListItemCount_FileListView(const ZKListView *pListView) {
    //LOGD("getListItemCount_FileListView !\n");
    return OM::FileSystem::GetItemCount();
}

static void obtainListItemData_FileListView(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::FileList::RenderFileListItem(pListItem, index);
}

static void onListItemClick_FileListView(ZKListView* pListView, int index, int id)
{
	UI::FileList::OnFileListItemClick(index);
}

static bool onButtonClick_PrintBabystepDecBtn(ZKButton *pButton) {
	Comm::DUET.SendGcode("M290 S-0.05");
	return false;
}

static bool onButtonClick_PrintBabystepIncBtn(ZKButton *pButton) {
	Comm::DUET.SendGcode("M290 S0.05");
	return false;
}

static int getListItemCount_PrintFanList(const ZKListView *pListView) {
    //LOGD("getListItemCount_PrintFanList !\n");
    return OM::GetFanCount();
}

static void obtainListItemData_PrintFanList(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) {
    OM::Fan* fan = OM::GetFanBySlot(index);
    if (fan == nullptr)
    {
    	return;
    }
	pListItem->setTextTrf("fan_status", fan->index, (int)(100 * fan->requestedValue));
}

static void onListItemClick_PrintFanList(ZKListView* pListView, int index, int id)
{
	OM::Fan* fan = OM::GetFanBySlot(index);
	if (fan == nullptr)
	{
		return;
	}
	size_t fanIndex = fan->index;
	UI::OpenSliderNumPad(
		utils::format(LANGUAGEMANAGER->getValue("fan_header").c_str(), fan->index).c_str(),
		"",
		"",
		"%",
		0,
		100,
		(int)(fan->requestedValue * 100),
		[fanIndex](int percent) {
			OM::Fan* fan = OM::GetFan(fanIndex);
			if (fan == nullptr)
			{
				return;
			}
			int fanSpeed = (percent * 255) / 100;
			Comm::DUET.SendGcodef("M106 P%d S%d\n", fan->index, fanSpeed);
		},
		true);
}

static bool onButtonClick_PrintPauseBtn(ZKButton *pButton) {
    OM::FileSystem::PausePrint();
    return false;
}

static bool onButtonClick_PrintCancelBtn(ZKButton *pButton) {
    OM::FileSystem::StopPrint();
    UI::WINDOW.Home();
    return false;
}

static bool onButtonClick_PrintResumeBtn(ZKButton *pButton) {
	OM::FileSystem::ResumePrint();
    return false;
}

static int getListItemCount_PrintPositionList(const ZKListView *pListView) {
    return OM::Move::GetAxisCount();
}

static void obtainListItemData_PrintPositionList(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) {
    ZKListView::ZKListSubItem* pMachinePosition = pListItem->findSubItemByID(ID_MAIN_PrintPositionListMachinePositionSubItem);
    ZKListView::ZKListSubItem* pUserPosition = pListItem->findSubItemByID(ID_MAIN_PrintPositionListUserPositionSubItem);
	OM::Move::Axis* axis = OM::Move::GetAxisBySlot(index);
	if (axis == nullptr) return;

	pListItem->setText(axis->letter);
	pUserPosition->setText(axis->userPosition);
	pMachinePosition->setTextf("(%.2f)", axis->machinePosition);
}

static void onListItemClick_PrintPositionList(ZKListView* pListView, int index, int id) {}

static int getListItemCount_PrintExtruderPositionList(const ZKListView *pListView) {
    //LOGD("getListItemCount_PrintExtruderPositionList !\n");
    return OM::Move::GetExtruderAxisCount();
}

static void obtainListItemData_PrintExtruderPositionList(ZKListView *pListView,ZKListView::ZKListItem *pListItem, int index) {
    ZKListView::ZKListSubItem* pSubItem = pListItem->findSubItemByID(ID_MAIN_PrintExtruderPositionListSubItem1);
	OM::Move::ExtruderAxis* extruder = OM::Move::GetExtruderAxisBySlot(index);
	if (extruder == nullptr) return;

	pListItem->setText(extruder->index);
	pSubItem->setText(extruder->position);
}

static void onListItemClick_PrintExtruderPositionList(ZKListView *pListView, int index, int id) {
	OM::Move::ExtruderAxis* extruder = OM::Move::GetExtruderAxisBySlot(index);
	if (extruder == nullptr)
	{
		return;
	}
	size_t extruderIndex = extruder->index;
	UI::OpenSliderNumPad(
		utils::format(LANGUAGEMANAGER->getValue("extrusion_factor_header").c_str(), extruderIndex).c_str(),
		"",
		"",
		"%",
		1,
		200,
		(int)(extruder->factor * 100),
		[extruderIndex](int percent) {
			OM::Move::ExtruderAxis* extruder = OM::Move::GetExtruderAxis(extruderIndex);
			if (extruder == nullptr)
			{
				return;
			}
			Comm::DUET.SendGcodef("M221 D%d S%d\n", extruder->index, percent);
		});
}

static void onProgressChanged_PrintSpeedMultiplierBar(ZKSeekBar *pSeekBar, int progress) {
	Comm::DUET.SendGcodef("M220 S%d\n", progress);
}

static int getListItemCount_PrintTemperatureList(const ZKListView *pListView) {
	return UI::ToolsList::Get("home")->GetTotalHeaterCount(false);
}

static void obtainListItemData_PrintTemperatureList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::ToolsList::Get("print")->ObtainListItemData(pListItem,
													index,
													ID_MAIN_PrintTemperatureListNameSubItem,
													ID_MAIN_PrintTemperatureListStatusSubItem,
													ID_MAIN_PrintTemperatureListCurrentSubItem,
													ID_MAIN_PrintTemperatureListActiveSubItem,
													ID_MAIN_PrintTemperatureListStandbySubItem);
}

static void onListItemClick_PrintTemperatureList(ZKListView *pListView, int index, int id) {
	UI::ToolsList::Get("print")->OnListItemClick(
			index, id,
			NULL, NULL,
			ID_MAIN_PrintTemperatureListActiveSubItem, ID_MAIN_PrintTemperatureListStandbySubItem);
}

static void onProgressChanged_Slider(ZKSeekBar *pSeekBar, int progress) {
	UI::SLIDER_WINDOW.Callback();
}

static bool onButtonClick_SliderCloseBtn(ZKButton *pButton) {
	UI::WINDOW.CloseOverlay();
	return false;
}
static bool onButtonClick_PopupCancelBtn(ZKButton* pButton)
{
	UI::POPUP_WINDOW.Cancel();
	return false;
}

static bool onButtonClick_PopupOkBtn(ZKButton* pButton)
{
	UI::POPUP_WINDOW.Ok();
	return false;
}

static void onSlideItemClick_SettingsSlideWindow(ZKSlideWindow* pSlideWindow, int index)
{
	switch (index)
	{
	case (int)UI::SettingsSlideWindowIndex::language:
		EASYUICONTEXT->openActivity("LanguageSettingActivity");
		break;
	case (int)UI::SettingsSlideWindowIndex::duet:
		mDuetUartCommSettingWindowPtr->setVisible(Comm::DUET.GetCommunicationType() ==
												  Comm::Duet::CommunicationType::uart);
		mDuetNetworkCommSettingWindowPtr->setVisible(Comm::DUET.GetCommunicationType() ==
													 Comm::Duet::CommunicationType::network);
		UI::WINDOW.OpenOverlay(mDuetCommSettingWindowPtr);
		break;
	case (int)UI::SettingsSlideWindowIndex::update:
		// EASYUICONTEXT->openActivity("UpgradeActivity");
		UI::POPUP_WINDOW.Open([]() {
			if (!UpgradeFromDuet())
			{
				registerDelayedCallback("upgrade_failed", 100, []() {
					UI::POPUP_WINDOW.Open();
					UI::POPUP_WINDOW.SetTitle(LANGUAGEMANAGER->getValue("upgrade_failed"));
					return false;
				});
			}
		});
		UI::POPUP_WINDOW.SetTitle(LANGUAGEMANAGER->getValue("upgrade_firmware").c_str());
		break;
	case (int)UI::SettingsSlideWindowIndex::restart:
		// Synchronise data and save cached data to prevent data loss
		sync();
		reboot(RB_AUTOBOOT);
		break;
	case (int)UI::SettingsSlideWindowIndex::dev:
		EASYUICONTEXT->openActivity("DeveloperSettingActivity");
		break;
	case (int)UI::SettingsSlideWindowIndex::power_off:
		EASYUICONTEXT->openActivity("PowerOffActivity");
		break;
	case (int)UI::SettingsSlideWindowIndex::zk_setting:
		EASYUICONTEXT->openActivity("ZKSettingActivity");
		break;
	case (int)UI::SettingsSlideWindowIndex::touch_calibration:
		EASYUICONTEXT->openActivity("TouchCalibrationActivity");
		break;
	case (int)UI::SettingsSlideWindowIndex::guides:
		UI::WINDOW.OpenOverlay(mGuideSelectionWindowPtr);
		break;
	case (int)UI::SettingsSlideWindowIndex::brightness:
		//! TODO: There is a bug in the flythings brightness api. Sometimes when calling it, the screen will go
		//! completely white and need a power cycle.
		UI::SLIDER_WINDOW.Open(LANGUAGEMANAGER->getValue("set_brightness").c_str(),
								"",
								"",
								"%",
								0,
								100,
								100 - BRIGHTNESSHELPER->getBrightness(),
								[](int percent) {
									BRIGHTNESSHELPER->setBrightness(100 - percent); // Flythings brightness is inverted
								});
		break;
	case (int)UI::SettingsSlideWindowIndex::theme:
		UI::WINDOW.OpenOverlay(mThemeSelectionWindowPtr);
		break;
	case (int)UI::SettingsSlideWindowIndex::screensaver:
		UI::WINDOW.OpenOverlay(mScreensaverSettingWindowPtr);
		break;
	case (int)UI::SettingsSlideWindowIndex::buzzer:
		UI::WINDOW.OpenOverlay(mBuzzerSettingWindowPtr);
		break;
	case (int)UI::SettingsSlideWindowIndex::webcam:
		UI::WINDOW.OpenOverlay(mWebcamSettingWindowPtr);
		break;
	default:
		break;
	}
}

static int getListItemCount_BaudRateList(const ZKListView* pListView)
{
	return ARRAY_SIZE(Comm::baudRates);
}

static void obtainListItemData_BaudRateList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setSelected(Comm::baudRates[index].rate == Comm::DUET.GetBaudRate().rate);
	pListItem->setText((int)Comm::baudRates[index].rate);
}

static void onListItemClick_BaudRateList(ZKListView* pListView, int index, int id)
{
	Comm::DUET.SetBaudRate(Comm::baudRates[index]);
}
static int getListItemCount_PopupSelectionList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_PopupSelectionList !\n");
	return OM::g_currentAlert.choices_count;
}

static void obtainListItemData_PopupSelectionList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(OM::g_currentAlert.choices[index].c_str());
}

static void onListItemClick_PopupSelectionList(ZKListView* pListView, int index, int id)
{
	Comm::DUET.SendGcodef("M292 R{%lu} S%lu\n", index, OM::g_currentAlert.seq);
	// LOGD(" onListItemClick_ PopupSelectionList  !!!\n");
}

static void onEditTextChanged_PopupTextInput(const std::string& text)
{
	if (UI::POPUP_WINDOW.GetMode() != OM::Alert::Mode::Text)
		return;
	UI::POPUP_WINDOW.ValidateTextInput(text.c_str());
}

static void onEditTextChanged_PopupNumberInput(const std::string& text)
{
	switch (UI::POPUP_WINDOW.GetMode())
	{
	case OM::Alert::Mode::NumberInt: {
		UI::POPUP_WINDOW.ValidateIntegerInput(text.c_str());
		break;
	}
	case OM::Alert::Mode::NumberFloat: {
		UI::POPUP_WINDOW.ValidateFloatInput(text.c_str());
		break;
	}
	default:
		break;
	}
}

static int getListItemCount_PopupAxisSelection(const ZKListView* pListView)
{
	return UI::POPUP_WINDOW.GetJogAxisCount();
}

static void obtainListItemData_PopupAxisSelection(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setSelected(index == UI::POPUP_WINDOW.selectedAxis);
	pListItem->setText(UI::POPUP_WINDOW.GetJogAxis(index)->letter);
}

static void onListItemClick_PopupAxisSelection(ZKListView* pListView, int index, int id)
{
	dbg("Popup axis selection %d", index);
	UI::POPUP_WINDOW.selectedAxis = index;
}

static int getListItemCount_PopupAxisAdjusment(const ZKListView* pListView)
{
	// LOGD("getListItemCount_PopupAxisAdjusment !\n");
	return ARRAY_SIZE(UI::POPUP_WINDOW.jogAmounts);
}

static void obtainListItemData_PopupAxisAdjusment(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::POPUP_WINDOW.jogAmounts[index]);
}

static void onListItemClick_PopupAxisAdjusment(ZKListView* pListView, int index, int id)
{
	Comm::DUET.SendGcode("M120\n"); // Push
	Comm::DUET.SendGcode("G91\n");	// Relative move
	Comm::DUET.SendGcodef("G1 %s%.3f F%d\n",
						  UI::POPUP_WINDOW.GetJogAxis(UI::POPUP_WINDOW.selectedAxis)->letter,
						  UI::POPUP_WINDOW.jogAmounts[index],
						  300);
	Comm::DUET.SendGcode("M121\n"); // Pop
}

static int getListItemCount_DuetCommList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_DuetCommList !\n");
	return (int)Comm::Duet::CommunicationType::COUNT;
}

static void obtainListItemData_DuetCommList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(Comm::duetCommunicationTypeNames[index]);
	pListItem->setSelected(index == (int)Comm::DUET.GetCommunicationType());
}

static void onListItemClick_DuetCommList(ZKListView* pListView, int index, int id)
{
	Comm::DUET.SetCommunicationType((Comm::Duet::CommunicationType)index);
	mDuetUartCommSettingWindowPtr->setVisible(Comm::DUET.GetCommunicationType() == Comm::Duet::CommunicationType::uart);
	mDuetNetworkCommSettingWindowPtr->setVisible(Comm::DUET.GetCommunicationType() ==
												 Comm::Duet::CommunicationType::network);
	mCommunicationTypePtr->setText(Comm::duetCommunicationTypeNames[index]);
}

static void onEditTextChanged_PollIntervalInput(const std::string& text)
{
	if (text.empty() || atoi(text.c_str()) < (int)MIN_PRINTER_POLL_INTERVAL)
	{
		mPollIntervalInputPtr->setText((int)MIN_PRINTER_POLL_INTERVAL);
		return;
	}
	Comm::DUET.SetPollInterval(atoi(text.c_str()));
}

static void onEditTextChanged_HostnameInput(const std::string& text)
{
	dbg("Hostname input changed to %s", text.c_str());
	Comm::DUET.SetHostname(text);
}

static void onEditTextChanged_PasswordInput(const std::string& text)
{
	Comm::DUET.SetPassword(text);
}

static void onEditTextChanged_InfoTimeoutInput(const std::string& text)
{
	int32_t timeout = -1;
	if (text.empty() || !Comm::GetInteger(text.c_str(), timeout) || timeout < 0)
	{
		mInfoTimeoutInputPtr->setText((int)UI::POPUP_WINDOW.GetTimeout());
		return;
	}
	UI::POPUP_WINDOW.SetTimeout((uint32_t)timeout);
}

static bool onButtonClick_UsbFiles(ZKButton* pButton)
{
	dbg(" ButtonClick UsbFiles !!!\n");
	OM::FileSystem::RequestUsbFiles("");
	return false;
}

static bool onButtonClick_ConsoleMacroBtn1(ZKButton* pButton)
{
	UI::WINDOW.OpenOverlay(mDebugWindowPtr);
	return false;
}

static bool onButtonClick_ConsoleMacroBtn2(ZKButton* pButton)
{
	UI::SLIDER_WINDOW.Open("Slider", "0", "100", "%", 0, 100, 50, [](int value) { dbg("Slider value: %d", value); });
	UI::SLIDER_WINDOW.SetPosition(UI::VerticalPosition::center, UI::HorizontalPosition::center);
	return false;
}

static bool onButtonClick_ConsoleMacroBtn3(ZKButton* pButton)
{
	Comm::DUET.SendGcode("M122");
	return false;
}
static bool onButtonClick_NextPageBtn(ZKButton* pButton)
{
	UI::GuidedSetup::GetCurrentGuide()->NextPage();
	return false;
}

static bool onButtonClick_PreviousPageBtn(ZKButton* pButton)
{
	UI::GuidedSetup::GetCurrentGuide()->PreviousPage();
	return false;
}

static void onCheckedChanged_ShowSetupOnStartup(ZKCheckBox* pCheckBox, bool isChecked)
{
	dbg("isChecked = %d", isChecked);
	StoragePreferences::putBool(ID_SHOW_SETUP_ON_STARTUP, isChecked);
}

static bool onButtonClick_CloseGuideBtn(ZKButton *pButton)
{
	UI::GuidedSetup::Close();
    return false;
}

static int getListItemCount_GuidesList(const ZKListView* pListView)
{
	return UI::GuidedSetup::GetGuideCount();
}

static void obtainListItemData_GuidesList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::GuidedSetup::Guide* guide = UI::GuidedSetup::GetGuideByIndex(index);
	if (guide == nullptr)
	{
		pListItem->setText("");
		return;
	}
	pListItem->setTextTr(guide->GetId());
}

static void onListItemClick_GuidesList(ZKListView* pListView, int index, int id)
{
	UI::GuidedSetup::Guide* guide = UI::GuidedSetup::GetGuideByIndex(index);
	if (guide == nullptr)
	{
		return;
	}
	UI::GuidedSetup::Show(guide->GetId());
}

static int getListItemCount_ExtruderFeedDist(const ZKListView* pListView)
{
	return UI::ExtrusionControl::GetExtrusionDistanceCount();
}

static void obtainListItemData_ExtruderFeedDist(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::ExtrusionControl::SetExtrusionDistanceListItem(pListItem, index);
}

static void onListItemClick_ExtruderFeedDist(ZKListView* pListView, int index, int id)
{
	UI::ExtrusionControl::ExtrusionDistanceListItemCallback(index);
}

static int getListItemCount_ExtruderFeedrate(const ZKListView* pListView)
{
	return UI::ExtrusionControl::GetExtrusionSpeedCount();
}

static void obtainListItemData_ExtruderFeedrate(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::ExtrusionControl::SetExtrusionSpeedListItem(pListItem, index);
}

static void onListItemClick_ExtruderFeedrate(ZKListView* pListView, int index, int id)
{
	UI::ExtrusionControl::ExtrusionSpeedListItemCallback(index);
}

static bool onButtonClick_RetractBtn(ZKButton* pButton)
{
	UI::ExtrusionControl::RetractFilament();
	return false;
}

static bool onButtonClick_ExtrudeBtn(ZKButton* pButton)
{
	UI::ExtrusionControl::ExtrudeFilament();
	return false;
}

static int getListItemCount_ExtrudeToolList(const ZKListView* pListView)
{
	return UI::ExtrusionControl::GetListCount();
}

static void obtainListItemData_ExtrudeToolList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::ExtrusionControl::SetExtrudeListItem(pListItem, index);
}

static void onListItemClick_ExtrudeToolList(ZKListView* pListView, int index, int id)
{
	UI::ExtrusionControl::ExtrudeListItemCallback(index, id);
}

static int getListItemCount_FilamentList(const ZKListView* pListView)
{
	return UI::ExtrusionControl::GetFilamentListCount();
}

static void obtainListItemData_FilamentList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::ExtrusionControl::SetFilamentListItem(pListItem, index);
}

static void onListItemClick_FilamentList(ZKListView* pListView, int index, int id)
{
	UI::ExtrusionControl::FilamentListItemCallback(index, id);
}

static bool onButtonClick_UnloadFilamentBtn(ZKButton* pButton)
{
	UI::ExtrusionControl::UnloadFilament();
	return false;
}

static void onCheckedChanged_ScreensaverEnable(ZKCheckBox* pCheckBox, bool isChecked)
{
	info("Screensaver %s", isChecked ? "enabled" : "disabled");
	StoragePreferences::putBool(ID_SCREENSAVER_ENABLE, isChecked);
	EASYUICONTEXT->setScreensaverEnable(isChecked);
}

static void onEditTextChanged_ScreensaverTimeoutInput(const std::string& text)
{
	int timeout = -1;
	if (!Comm::GetInteger(text.c_str(), timeout))
	{
		// Invalid input
		return;
	}
	if (timeout < 0)
	{
		mScreensaverTimeoutInputPtr->setText(10);
		return;
	}
	StoragePreferences::putInt(ID_SCREENSAVER_TIMEOUT, timeout);
	EASYUICONTEXT->setScreensaverTimeOut(timeout);
}
static bool onButtonClick_Button1(ZKButton *pButton) {
    LOGD(" ButtonClick Button1 !!!\n");
    return false;
}

static void onEditTextChanged_EditText2(const std::string &text) {
    //LOGD(" onEditTextChanged_ EditText2 %s !!!\n", text.c_str());
}

static void onProgressChanged_SeekBar1(ZKSeekBar *pSeekBar, int progress) {
    //LOGD(" ProgressChanged SeekBar1 %d !!!\n", progress);
}

static void onCheckedChanged_Checkbox1(ZKCheckBox* pCheckBox, bool isChecked) {
    LOGD(" Checkbox Checkbox1 checked %d", isChecked);
}

static int getListItemCount_ListView1(const ZKListView *pListView) {
    //LOGD("getListItemCount_ListView1 !\n");
    return 5;
}

static void obtainListItemData_ListView1(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setSelected(index == 0);
}

static void onListItemClick_ListView1(ZKListView *pListView, int index, int id) {
    //LOGD(" onListItemClick_ ListView1  !!!\n");
}

static void onSlideItemClick_SlideWindow2(ZKSlideWindow *pSlideWindow, int index) {
    //LOGD(" onSlideItemClick_ SlideWindow2 %d !!!\n", index);
}

static int getListItemCount_ThemesList(const ZKListView* pListView)
{
	return UI::Theme::GetThemeCount();
}

static void obtainListItemData_ThemesList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::Theme::Theme* theme = UI::Theme::GetThemeByIndex(index);
	if (theme == nullptr)
	{
		pListItem->setText("");
		return;
	}
	pListItem->setTextTr(theme->id.c_str());
	pListItem->setSelected(theme->id == UI::Theme::GetCurrentTheme()->id);
}

static void onListItemClick_ThemesList(ZKListView* pListView, int index, int id)
{
	UI::Theme::Theme* theme = UI::Theme::GetThemeByIndex(index);
	if (theme == nullptr)
	{
		return;
	}
	UI::Theme::SetTheme(theme);
}
static int getListItemCount_DebugCommandList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_DebugCommandList !\n");
	return Debug::GetCommandCount();
}

static void obtainListItemData_DebugCommandList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	Debug::DebugCommand* command = Debug::GetCommandByIndex(index);
	if (command == nullptr)
	{
		pListItem->setText("");
		return;
	}
	pListItem->setTextTr(command->id);
}

static void onListItemClick_DebugCommandList(ZKListView* pListView, int index, int id)
{
	Debug::DebugCommand* command = Debug::GetCommandByIndex(index);
	if (command == nullptr)
	{
		return;
	}
	command->callback();
}

static bool onButtonClick_OverlayModalZone(ZKButton* pButton)
{
	UI::WINDOW.CloseOverlay();
	return false;
}

static int getListItemCount_TempGraphXLabels(const ZKListView* pListView)
{
	// LOGD("getListItemCount_TempGraphXLabels !\n");
	return pListView->getCols();
}

static void obtainListItemData_TempGraphXLabels(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	int range = UI::TEMPERATURE_GRAPH.GetTimeRange();
	int time = -range + (index * range / (pListView->getCols() - 1));
	pListItem->setTextf("%ds", time);
}

static void onListItemClick_TempGraphXLabels(ZKListView* pListView, int index, int id)
{
	// LOGD(" onListItemClick_ TempGraphXLabels  !!!\n");
}

static int getListItemCount_TempGraphYLabels(const ZKListView* pListView)
{
	// LOGD("getListItemCount_TempGraphYLabels !\n");
	return pListView->getRows();
}

static void obtainListItemData_TempGraphYLabels(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	float yMax = UI::TEMPERATURE_GRAPH.GetYMax();
	float label = yMax - (yMax / (pListView->getRows() - 1)) * index;
	pListItem->setTextf("%.1f", label);
}

static void onListItemClick_TempGraphYLabels(ZKListView* pListView, int index, int id)
{
	// LOGD(" onListItemClick_ TempGraphYLabels  !!!\n");
}

static void onProgressChanged_PopupProgress(ZKSeekBar* pSeekBar, int progress)
{
	// LOGD(" ProgressChanged PopupProgress %d !!!\n", progress);
}

static int getListItemCount_HeightMapList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_HeightMapList !\n");
	return OM::GetHeightmapFiles().size();
}

static void obtainListItemData_HeightMapList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	ZKListView::ZKListSubItem* pLoad = pListItem->findSubItemByID(ID_MAIN_HeightmapLoad);

	std::string filename = OM::GetHeightmapNameAt(index);

	bool shown = filename == UI::GetVisibleHeightmapName().c_str();
	bool loaded = filename == OM::GetCurrentHeightmap().c_str();

	verbose("Heightmap %d: %s, shown: %d (%s), loaded: %d (%s)",
			index,
			filename.c_str(),
			shown,
			UI::GetVisibleHeightmapName().c_str(),
			loaded,
			OM::GetCurrentHeightmap().c_str());

	pListItem->setText(filename);
	pListItem->setSelected(shown);
	pLoad->setTextTr(loaded ? "unload_heightmap" : "load_heightmap");
}

static void onListItemClick_HeightMapList(ZKListView* pListView, int index, int id)
{
	dbg("Selected heightmap %d", index);
	std::string filename = OM::GetHeightmapNameAt(index);
	dbg("heightmap = %s", filename.c_str());
	if (filename.empty())
	{
		return;
	}
	if (id == ID_MAIN_HeightmapLoad)
	{
		OM::ToggleHeightmap(filename.c_str());
	}
	UI::RenderHeightmap(filename);
}

static bool onButtonClick_HeightMapRefresh(ZKButton* pButton)
{
	OM::RequestHeightmapFiles();
	UI::ClearHeightmap();
	return false;
}

static int getListItemCount_HeightMapScaleList(const ZKListView* pListView)
{
	return 5;
}

static void obtainListItemData_HeightMapScaleList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::GetHeightmapScaleAt(index));
}

static void onListItemClick_HeightMapScaleList(ZKListView* pListView, int index, int id) {}

static int getListItemCount_HeightMapColorSchemeList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_HeightMapColorSchemeList !\n");
	return 2;
}

static void obtainListItemData_HeightMapColorSchemeList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::GetHeightmapRenderModeText(UI::HeightmapRenderMode(index)));
    pListItem->setSelected(index == StoragePreferences::getInt(ID_HEIGHTMAP_RENDER_MODE, 0));
}

static void onListItemClick_HeightMapColorSchemeList(ZKListView* pListView, int index, int id)
{
	UI::SetHeightmapRenderMode(UI::HeightmapRenderMode(index));
}
static int getListItemCount_HeightMapYAxis(const ZKListView* pListView)
{
	// LOGD("getListItemCount_HeightMapYAxis !\n");
	return 5;
}

static void obtainListItemData_HeightMapYAxis(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::GetHeightmapYAxisText(index));
}

static void onListItemClick_HeightMapYAxis(ZKListView* pListView, int index, int id)
{
	// LOGD(" onListItemClick_ HeightMapYAxis  !!!\n");
}

static int getListItemCount_HeightMapXAxis(const ZKListView* pListView)
{
	return 5;
}

static void obtainListItemData_HeightMapXAxis(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::GetHeightmapXAxisText(index));
}

static void onListItemClick_HeightMapXAxis(ZKListView* pListView, int index, int id) {}

static void onCheckedChanged_BuzzerEnabled(ZKCheckBox* pCheckBox, bool isChecked)
{
	CONFIGMANAGER->setBeepEnable(isChecked);
	StoragePreferences::putBool(ID_BUZZER_ENABLED, isChecked);
}

static int getListItemCount_ObjectCancelObjectsList(const ZKListView* pListView)
{
	return OM::GetJobObjectCount();
}

static void obtainListItemData_ObjectCancelObjectsList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	UI::ObjectCancel::SetObjectLabel(pListItem, index);
}

static void onListItemClick_ObjectCancelObjectsList(ZKListView* pListView, int index, int id)
{
	UI::ObjectCancel::CancelJobObject(index);
}

static int getListItemCount_ObjectCancelYAxis(const ZKListView* pListView)
{
	return 5;
}

static void obtainListItemData_ObjectCancelYAxis(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::ObjectCancel::GetObjectCancelYAxisText(index));
}

static void onListItemClick_ObjectCancelYAxis(ZKListView* pListView, int index, int id) {}

static int getListItemCount_ObjectCancelXAxis(const ZKListView* pListView)
{
	return 5;
}

static void obtainListItemData_ObjectCancelXAxis(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(UI::ObjectCancel::GetObjectCancelXAxisText(index));
}

static void onListItemClick_ObjectCancelXAxis(ZKListView* pListView, int index, int id) {}

static bool onButtonClick_CancelCurrentObjectBtn(ZKButton* pButton)
{
	UI::ObjectCancel::CancelCurrentJobObject();
	return false;
}

static int getListItemCount_WebcamSelectList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_WebcamSelectList !\n");
	return UI::Webcam::GetWebcamCount();
}

static void obtainListItemData_WebcamSelectList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setText(index);
	pListItem->setSelected(index == (int)UI::Webcam::GetActiveWebcamIndex());
}

static void onListItemClick_WebcamSelectList(ZKListView* pListView, int index, int id)
{
	UI::Webcam::SetActiveWebcamIndex(index);
}

static int getListItemCount_WebcamUrlList(const ZKListView* pListView)
{
	// LOGD("getListItemCount_WebcamUrlList !\n");
	return UI::Webcam::GetWebcamCount();
}

static void obtainListItemData_WebcamUrlList(ZKListView* pListView, ZKListView::ZKListItem* pListItem, int index)
{
	pListItem->setTextf("[%d] %s", index, UI::Webcam::GetWebcamUrl(index).c_str());
}

static void onListItemClick_WebcamUrlList(ZKListView* pListView, int index, int id)
{
	switch (id)
	{
	case ID_MAIN_DeleteWebcamSubItem:
		UI::Webcam::DeleteWebcam(index);
		break;
	default:
		UI::Webcam::OpenWebcamUrlInput(index);
		break;
	}
}

static bool onButtonClick_AddWebcamBtn(ZKButton* pButton)
{
	UI::Webcam::AddNewWebcam();
	return false;
}

static void onEditTextChanged_WebcamUpdateIntervalInput(const std::string& text)
{
	UI::Webcam::SetWebcamUpdateInterval(atoi(text.c_str()));
}
