#pragma once
#include "Debug.h"
#include "Hardware/Duet.h"
#include "control/ZKTextView.h"

/*
 * This file is generated by the GUI tool.
 * File function: Used to handle user logic response code.
 * Function description:
 * ========================onButtonClick_XXXX
 * When a button is pressed in the page, the system will call the corresponding function.
 * XXX represents the [identifier] name in the GUI tool, such as Button1.
 * If the return value is false, the system will not process the button.
 * If the return value is true, the system will continue to process the button.
 * For example, SYS_BACK.
 * ========================onSlideWindowItemClick_XXXX(int index)
 * When a slide window exists in the page and the user clicks on the icon of the slide window,
 * the system will call this function.
 * XXX represents the [identifier] name in the GUI tool, such as slideWindow1.
 * index represents the offset value of the clicked icon.
 * ========================onSeekBarChange_XXXX(int progress)
 * When a seek bar exists in the page and the user changes the progress,
 * the system will call this function.
 * XXX represents the [identifier] name in the GUI tool, such as SeekBar1.
 * progress represents the current progress value.
 * ========================ogetListItemCount_XXXX()
 * When a slide list exists in the page and needs to be updated,
 * the system will call this interface to get the total number of items in the list.
 * XXX represents the [identifier] name in the GUI tool, such as List1.
 * The return value is the total number of items in the current list.
 * ========================oobtainListItemData_XXXX(ZKListView::ZKListItem *pListItem, int index)
 * When a slide list exists in the page and needs to be updated,
 * the system will call this interface to get the content information of the current item in the list.
 * XXX represents the [identifier] name in the GUI tool, such as List1.
 * pListItem is the single item object in the image, and index is the offset value of the total list items.
 * See function description for details.
 * ========================Common Interfaces===============
 * LOGD(...) - Interface for printing debug information.
 * mTextXXX->setText("****") - Display text on the TextXXX control.
 * mButton1->setSelected(true) - Set the mButton1 control to selected mode.
 * The image will switch to the selected image, and the button text will switch to the selected color.
 * mSeekBar->setProgress(12) - Adjust the progress to 12 on the mSeekBar control.
 * mListView1->refreshListView() - Refresh the mListView1 when the list data changes.
 * mDashbroadView1->setTargetAngle(120) - Adjust the pointer display angle to 120 degrees on the mDashbroadView1
 * control.
 */

/**
 * Register timers
 * Fill the array to register timers
 * Note: id must not be duplicated
 */
static S_ACTIVITY_TIMEER REGISTER_ACTIVITY_TIMER_TAB[] = {
	{0, 50},
};

static int s_xOffset = 1;
static int s_yOffset = 1;

/**
 * Triggered when the UI is initialized
 */
static void onUI_init()
{
	// Tips: Add UI initialization display code here, such as mText1->setText("123");
	info("Screensaver UI init");
	Comm::DUET.ScalePollIntervalScale(5);
	LayoutPosition position = mScreensaverTextPtr->getPosition();
	position.mLeft = 10;
	position.mTop = 10;
	s_xOffset = 1;
	s_yOffset = 1;
	mScreensaverTextPtr->setPosition(position);
}

/*
 * Triggered when the UI is completely exited
 */
static void onUI_quit()
{
	Comm::DUET.ScalePollIntervalScale(1);
}

/**
 * Serial data callback interface
 */
static void onProtocolDataUpdate(const SProtocolData& data)
{
	// Serial data callback interface
}

/**
 * Timer trigger function
 * It is not recommended to write time-consuming operations in this function,
 * otherwise it will affect UI refresh.
 * Parameters: id
 *             The id of the current triggered timer, which is the same as the id registered.
 * Return value: true
 *                  Continue to run the current timer.
 *              false
 *                  Stop running the current timer.
 */
static bool onUI_Timer(int id)
{
	switch (id)
	{
	case 0: {
		static ZKTextView* textPtr = mScreensaverTextPtr;
		if (textPtr == nullptr)
		{
			return true;
		}
		LayoutPosition position = textPtr->getPosition();
		if (position.mLeft < 10)
		{
			s_xOffset = 1;
		}
		else if (position.mLeft + position.mWidth > 1014)
		{
			s_xOffset = -1;
		}
		if (position.mTop < 10)
		{
			s_yOffset = 1;
		}
		else if (position.mTop + position.mHeight > 590)
		{
			s_yOffset = -1;
		}
		position.offsetPosition(s_xOffset, s_yOffset);
		textPtr->setPosition(position);
	}
	default:
		break;
	}
	return true;
}

/**
 * Triggered when there is a new touch event
 * Parameters: ev
 *             The new touch event
 * Return value: true
 *                  Indicates that the touch event is intercepted here,
 *                  and the system will not pass this touch event to the control.
 *              false
 *                  The touch event will continue to be passed to the control.
 */
static bool onscreensaverActivityTouchEvent(const MotionEvent& ev)
{
	switch (ev.mActionStatus)
	{
	case MotionEvent::E_ACTION_DOWN: // Touch down
		// LOGD("Time = %ld, Coordinates: x = %d, y = %d", ev.mEventTime, ev.mX, ev.mY);
		break;
	case MotionEvent::E_ACTION_MOVE: // Touch move
		break;
	case MotionEvent::E_ACTION_UP: // Touch up
		break;
	default:
		break;
	}
	return false;
}
